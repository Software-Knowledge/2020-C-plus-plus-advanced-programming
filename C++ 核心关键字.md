c++核心特殊关键字
---

<!-- TOC -->

- [1. friend关键字](#1-friend关键字)
  - [1.1. 友元函数](#11-友元函数)
  - [1.2. 友元类](#12-友元类)
- [2. this关键字](#2-this关键字)
  - [2.1. 用法](#21-用法)
  - [2.2. 注意](#22-注意)
- [3. volatile](#3-volatile)
  - [3.1. 易变性](#31-易变性)
  - [3.2. 不可优化](#32-不可优化)
  - [3.3. 顺序性](#33-顺序性)
  - [3.4. 参考](#34-参考)
- [4. static 关键词](#4-static-关键词)
  - [4.1. 成员函数](#41-成员函数)
  - [4.2. 数据成员](#42-数据成员)
- [5. const类型](#5-const类型)

<!-- /TOC -->

# 1. friend关键字
1. private和protected不能从声明它们的同一类外部访问。
2. 被friend关键字修饰的函数或类成为友元函数或友元类。

## 1.1. 友元函数
1. 友元函数是可以直接访问类的私有成员的非成员函数。(不需要通过public部分的接口)
2. 它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需要在友元的名称前加上关键词friend。
3. 声明格式:`friend 类型 函数名(形式参数);`
    + 友元函数的声明可以放在类的私有部分，也可以放在公有部分，这并没有区别。
    + 一个函数可以是多个类的友元函数，只要在多个类中声明即可。

## 1.2. 友元类
1. 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息(包含私有成员和保护成员)。
2. 语法:`friend class 类名;`
3. 注意:
    1. 友元关系不能被继承。
    2. 友元关系是单向的，不具有交换性。
    3. 友元关系具有非传递性。

# 2. this关键字
1. 在C++中，每一个对象都可以通过this指针来访问自己的地址。
2. this是所有成员函数的隐藏参数。

## 2.1. 用法
1. 如果有某个变量和成员变量相同，那么用this来引用成员变量
2. 需要返回变量或结构体变量时，使用this关键字。

## 2.2. 注意
1. 友元函数没有this指针
2. this关键字之能用于成员函数，不能被修饰static的函数。
3. 因为在C++中，this关键字是一个指向对象自己的指针，不能加点，而是用->

# 3. volatile

## 3.1. 易变性
1. 也就是在汇编层面上来讲，下一条语句不会直接使用上一条语句的volatile变量的寄存器内容，而是重新从内存读取。

## 3.2. 不可优化
1. volatile告诉编译器，不要对这个变量进行优化，保证程序员写在代码中的指令一定会被执行。

## 3.3. 顺序性
1. 保证在多线程情况下的一定的处理顺序

## 3.4. 参考
<a href = "https://www.cnblogs.com/god-of-death/p/7852394.html">解释volatile关键字</a>

# 4. static 关键词
1. 用static可以为类类型的所有对象所共有，像是全局对象，但又被约束在类类型的名字空间中。static定义的静态变量在函数执行后不会释放其存储空间。
   - 修饰一个全局变量只对定义在同一文件中的函数可见：其他文件可以定义相同名字的变量。
   - 修饰局部变量，这个变量值不会因为函数终止而丢失，该变量在全局函数区分配内存(局部变量在栈区)
2. 可以实施封装，将其放在private和protected区域
3. static成员没有this指针，它不是任何一个对象的组成部分，推荐使用"类名::static成员名"调用

## 4.1. 成员函数
1. 声明时候写static关键词
2. 定义时候不写static关键词
3. 不可以使用const以修饰其不改变其成员属性。`static void f() const{};//error`，因为static函数不包含this指针
4. 不能使用virtual修饰其虚拟性
5. 目的:作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致
   1. 不能直接存储类的非静态成员变量，调用非静态成员函数
   2. 不能被声明为virtual

## 4.2. 数据成员
1. 声明时候写static关键词
2. 定义时候不写static关键词，如果定义的时候加了，其实是变成了**文件作用域**
3. `static const`数据成员
   1. 可以在类中声明并且初始化，然后在类定义之外再次进行定义
   2. 或者在类中声明，但在类定义外进行定义。
4. **非const的static数据成员仅能在类中声明，并在类定义之外进行定义。**

# 5. const类型
1. const定义的常量在超出其作用域之后**其空间会被释放**
   1. const数据成员只在某个对象生存期内是常量
   2. 对于整个类是可变的，因为类是可以创建多个对象，对于不同对象其const数据成员的值可以不同
2. const数据成员的初始化**只能在类的构造函数的初始化列表中进行**，想要建立在整个类中都恒定的常量，应该用类对的枚举常量来实现，或者static const
3. const成员函数主要目的是防止成员函数修改对象的内容。即const成员函数不能修改成员变量的值，但是可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。
4. **数组成员不能在初始化列表中初始化**